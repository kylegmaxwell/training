#include "binarytree.h"
#include <stack>
#include <utility> // pair
#include <math.h>
#include <algorithm>
#include <climits>

using namespace std;

// This tree is generated by the builBalancedTree function below
//               b8
//       c5              h10
//   d3      g6      i9      j11
// e2  f4
BinaryNodePtr BinaryTree::buildBalancedTree()
{
    BinaryNodePtr b(new BinaryNode(8));
    BinaryNodePtr c(new BinaryNode(5));
    BinaryNodePtr d(new BinaryNode(3));
    BinaryNodePtr e(new BinaryNode(2));
    BinaryNodePtr f(new BinaryNode(4));
    BinaryNodePtr g(new BinaryNode(6));
    BinaryNodePtr h(new BinaryNode(10));
    BinaryNodePtr i(new BinaryNode(9));
    BinaryNodePtr j(new BinaryNode(11));

    b->mLeft = c;
    b->mRight = h;
    c->mLeft = d;
    c->mRight = g;
    d->mLeft = e;
    d->mRight = f;
    h->mLeft = i;
    h->mRight = j;

    return b;
}

// This tree is generated by the buildUnbalancedTree function below
//               b6
//       c271            f561
//   d28      e0            g3
//                      h17
BinaryNodePtr BinaryTree::buildUnbalancedTree()
{
    BinaryNodePtr b(new BinaryNode(6));
    BinaryNodePtr c(new BinaryNode(271));
    BinaryNodePtr d(new BinaryNode(28));
    BinaryNodePtr e(new BinaryNode(0));
    BinaryNodePtr f(new BinaryNode(561));
    BinaryNodePtr g(new BinaryNode(3));
    BinaryNodePtr h(new BinaryNode(17));

    b->mLeft = c;
    b->mRight = f;
    c->mLeft = d;
    c->mRight = e;
    f->mRight = g;
    g->mLeft = h;

    return b;
}

bool BinaryTree::isBalanced(BinaryNodePtr node)
{
    int d = 0;
    if (node)
        return isBalancedHelper(node, d);
    else
        return false;
}

bool BinaryTree::isBalancedHelper(BinaryNodePtr node, int &depth)
{
    int leftDepth = depth;
    int rightDepth = depth;
    if (node->mLeft != nullptr) {
        leftDepth++;
        if (!isBalancedHelper(node->mLeft, leftDepth))
            return false; // return as early as possible to save computation
    }

    if (node->mRight != nullptr) {
        rightDepth++;
        if (!isBalancedHelper(node->mRight, rightDepth))
            return false;
    }

    depth = max<int>(leftDepth, rightDepth);

    if (abs(leftDepth - rightDepth) > 1)
        return false;

    return true;
}

bool BinaryTree::processNode(BinaryNodePtr n, int &prev)
{
    if (mVerbose)
        cout << n->mData << " ";

    if (n->mData < prev)
        return false;

    prev = n->mData;

    return true;
}

bool BinaryTree::isSorted(BinaryNodePtr node)
{
    // node, whether to push children
    typedef pair<BinaryNodePtr, bool> NodeBool;

    stack<NodeBool> nodeStack;
    nodeStack.push(NodeBool(node, true));

    int prev = INT_MIN;

    while (!nodeStack.empty()) {
        // get the next element and pop it
        NodeBool nb = nodeStack.top();
        BinaryNodePtr n = nb.first;
        bool pushChildren = nb.second;
        nodeStack.pop();

        // Perform node processing operation
        if (!pushChildren) {
            if (!processNode(n, prev))
                return false;
        }

        // add children to stack
        if (n->mRight && pushChildren)
            nodeStack.push(NodeBool(n->mRight, true));

        if (pushChildren)
            nodeStack.push(NodeBool(n, false));

        if (n->mLeft && pushChildren)
            nodeStack.push(NodeBool(n->mLeft, true));
    }
    return true;
}

bool BinaryTree::isSortedRecursive(BinaryNodePtr node, int &prev)
{
    if (!node)
        return true;

    if (!isSortedRecursive(node->mLeft, prev))
        return false;

    // perform node processing operation
    if (!processNode(node, prev))
        return false;

    if (!isSortedRecursive(node->mRight, prev))
        return false;

    return true;
}

UnitTest::TestResult BinaryTree::test()
{
    BinaryNodePtr treeGood = buildBalancedTree();

    if (!isBalanced(treeGood))
        return FAIL;

    BinaryNodePtr treeBad = buildUnbalancedTree();
    if (isBalanced(treeBad))
        return FAIL;

    if (!isSorted(treeGood))
        return FAIL;

    if (isSorted(treeBad))
        return FAIL;

    int prev = INT_MIN;
    if (!isSortedRecursive(treeGood, prev))
        return FAIL;

    prev = INT_MIN;
    if (isSortedRecursive(treeBad, prev))
        return FAIL;

    return PASS;
}

BinaryNode::BinaryNode(int iData)
    : mData(iData), mLeft(nullptr), mRight(nullptr)
{
}

BinaryNode::BinaryNode(int iData, BinaryNode *iLeft, BinaryNode *iRight)
    : mData(iData), mLeft(iLeft), mRight(iRight)
{
}

BinaryNode::~BinaryNode()
{
}